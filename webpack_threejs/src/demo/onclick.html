<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style type="text/css">
    html,
    body {
      margin: 0;
      height: 100%;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body onload="draw();">

</body>
<script src="./lib/three.js"></script>
<script src="./lib/js/controls/OrbitControls.js"></script>
<script src="./lib/js/libs/stats.min.js"></script>
<script src="./lib/js/libs/dat.gui.min.js"></script>
<script>
  let renderer;

  function initRender() {
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    //告诉渲染器需要阴影效果
    //renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
    renderer.setClearColor(0xffffff);
    document.body.appendChild(renderer.domElement);
  }

  let camera;

  function initCamera() {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 100);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
  }

  let scene;

  function initScene() {
    scene = new THREE.Scene();
  }

  function initLight() {

  }

  function initModel() {

    //辅助工具
    let helper = new THREE.AxesHelper(10);
    scene.add(helper);

    let s = 25;

    let cube = new THREE.CubeGeometry(s, s, s);

    for (let i = 0; i < 3000; i++) {

      let material = new THREE.MeshBasicMaterial({ color: randomColor() });

      let mesh = new THREE.Mesh(cube, material);

      mesh.position.x = 800 * (2.0 * Math.random() - 1.0);
      mesh.position.y = 800 * (2.0 * Math.random() - 1.0);
      mesh.position.z = 800 * (2.0 * Math.random() - 1.0);

      mesh.rotation.x = Math.random() * Math.PI;
      mesh.rotation.y = Math.random() * Math.PI;
      mesh.rotation.z = Math.random() * Math.PI;

      mesh.updateMatrix();

      scene.add(mesh);

    }

  }

  //随机生成颜色
  function randomColor() {
    let arrHex = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"],strHex = "#",index;
    for (let i = 0; i < 6; i++) {
      index = Math.round(Math.random() * 15);
      strHex += arrHex[index];
    }
    return strHex;
  }

  //声明raycaster和mouse变量
  let raycaster = new THREE.Raycaster();
  let mouse = new THREE.Vector2();

  function onMouseClick(event) {

    //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

    // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
    raycaster.setFromCamera(mouse, camera);

    // 获取raycaster直线和所有模型相交的数组集合
    let intersects = raycaster.intersectObjects(scene.children);

    console.log(intersects);

    //将所有的相交的模型的颜色设置为红色，如果只需要将第一个触发事件，那就数组的第一个模型改变颜色即可
    for (let i = 0; i < intersects.length; i++) {

      intersects[i].object.material.color.set(0xff0000);

    }

  }

  window.addEventListener('click', onMouseClick, false);

  //初始化dat.GUI简化试验流程
  let gui;

  function initGui() {
    //声明一个保存需求修改的相关数据的对象
    controls = {

    };

    let gui = new dat.GUI();

  }

  //初始化性能插件
  let stats;

  function initStats() {
    stats = new Stats();
    document.body.appendChild(stats.dom);
  }

  //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
  let controls;

  function initControls() {

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    // 如果使用animate方法时，将此函数删除
    //controls.addEventListener( 'change', render );
    // 使动画循环使用时阻尼或自转 意思是否有惯性
    controls.enableDamping = true;
    //动态阻尼系数 就是鼠标拖拽旋转灵敏度
    //controls.dampingFactor = 0.25;
    //是否可以缩放
    controls.enableZoom = true;
    //是否自动旋转
    controls.autoRotate = false;
    //设置相机距离原点的最远距离
    controls.minDistance = 50;
    //设置相机距离原点的最远距离
    controls.maxDistance = 200;
    //是否开启右键拖拽
    controls.enablePan = true;
  }

  function render() {
    renderer.render(scene, camera);
  }

  //窗口变动触发的函数
  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    render();
    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function animate() {
    //更新控制器
    render();

    //更新性能插件
    stats.update();

    //controls.update();

    requestAnimationFrame(animate);
  }

  function draw() {
    initRender();
    initScene();
    initCamera();
    initLight();
    initModel();
    initGui();
    initControls();
    initStats();

    animate();
    window.onresize = onWindowResize;
  }
</script>

</html>